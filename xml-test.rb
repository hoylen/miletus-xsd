#!/usr/bin/ruby -w

require 'optparse'
require 'stringio'

#================================================================

def process_command_line

  # Specify command line options

  options = {}
  opt_parser = OptionParser.new do |opt|
    opt.banner = "Usage: PROG [options] XMLSchemaFiles"

    opt.separator "Options:"

    opt.on("-o", "--output outfile", "output file name") do |param|
      options[:output] = param
    end

    opt.on("-m", "--module name", "module") do |param|
      options[:module] = param
    end

    opt.on("-P", "--parser code", "parser code") do |param|
      options[:parser] = param
    end

    opt.on("-v", "--verbose", "verbose output") do
      options[:verbose] = true
    end

    opt.on("-h", "--help", "show help message") do
      $stderr.puts opt_parser
      exit 0
    end
  end
  opt_parser.version = 1.0
  opt_parser.release = 1024

  # Parse parameters

  begin
    opt_parser.parse!
  rescue OptionParser::InvalidOption => e
    $stderr.puts "Usage error: #{e.message} (--help for help)"
    exit 2
  rescue OptionParser::InvalidArgument => e
    $stderr.puts "Usage error: #{e.message}"
    exit 2
  end

  # Use parameters

  if ! options[:parser] then
    $stderr.puts "Usage error: missing --parser"
    exit 2
  end
  if ! options[:module] then
    $stderr.puts "Usage error: missing --module"
    exit 2
  end

  if ARGV.empty? then
    $stderr.puts "Usage error: missing XML file (-h for help)"
    exit 2
  end

  return ARGV, options[:verbose], options[:output], options[:parser], options[:module]

end # def process_command_line

#----------------------------------------------------------------

def main

  filenames, verbose, outfile_name, parser_src, parser_module = process_command_line

  # Load the XML parsing code (which was generated by 'xsd-to-ruby.rb')
  # And create its Parser object

  load parser_src

#  parser = nil
  begin
    mod = eval "#{parser_module}"
  rescue NameError => e
    $stderr.puts "Error: no such module: #{parser_module} (check \"#{parser_src}\")"
    exit 1
  end
#method(:parse)
  begin
#    parser = eval "#{parser_module}::Parser.new"
  rescue NameError => e
    $stderr.puts "Error: Parser class does not exist in module: #{parser_module}"
    $stderr.puts "       was it correctly generated by \'xsd-to-ruby.rb\'?"
    exit 1
  end

  # Parse each XML instance file

  filenames.each do |filename|

    if verbose then
      puts "Parsing #{filename}"
    end

    data, name = mod.parse(File.new(filename))
#    data, name = parser.parse(File.new(filename))

    if false
      puts "parsed: #{data}"
      # This sequence contains only one array called registryObject
      puts "  the registryObject in the sequence is an array: #{data.registryObject.class}"
      data.registryObject.each do |ro|
        puts "    registryObject: #{ro}"
        puts "    registryObject.key: #{ro.key}"
        puts "    registryObject.originatingSource (_value): #{ro.originatingSource._value}"
        puts "    registryObject.choice1: #{ro.choice1._option}"
      end
    end

    sio = StringIO.new
    data.xml('root', sio)
    s = sio.string
    puts s

  end

  puts "Success"

  0 # success
end

exit main

#EOF
